// --- CONFIG ---
        const urlDoWebhookN8N = 'https://aldeia0225.app.n8n.cloud/webhook/a83cd7e6-b8e4-49ea-b524-9780b993c9ad';
        const DATA_REFRESH_INTERVAL = 3600 * 1000;
        const VIEW_ROTATION_INTERVAL = 15 * 1000;
        const TEAMS = {
            'DOLLAR GODS': ['Felipe', 'Natan', 'Allison', 'João', 'Raul', 'Otavio', 'Lucas Vinicius'],
            'ELITE SQUAD': ['Luan', 'Victor', 'G. Dias', 'G. Wagner', 'Ruan', 'Arthur', 'Laurence', 'Davi']
        };
        const BROKER_MAP = {
            'Felipe Pauluk': 'Felipe', 'Felipe Enos': 'Felipe', 'João Lucas': 'João', 
            'Gabriel Dias': 'G. Dias', 'Gabriel Wagner': 'G. Wagner',
            'Luan Felipe': 'Luan', 'Victor Renan': 'Victor', 'Ruan Neuberger': 'Ruan', 
            'Arthur De Oliveira': 'Arthur', 'Laurence Dias': 'Laurence', 
            'Davi Dias do Nascimento': 'Davi', 'Allison Moreira': 'Allison', 
            'Otavio': 'Otavio', 'Raul': 'Raul', 'Natan': 'Natan', 'Lucas Vinicius': 'Lucas'
        };

        // --- STATE ---
        let rawData = [], mainChartInstance = null;
        let dataRefreshIntervalId, countdownIntervalId, rotationTimeoutId, animationFrameId;
        let rotationStartTime, rotationRemainingTime = VIEW_ROTATION_INTERVAL;
        let currentRankingType = 'value', currentPeriod = '', currentViewIndex = 0;
        let previousRankings = {}, isPaused = false;
        
        const views = ['view-teams', 'view-leaderboard', 'view-chart'];
        const DOM = {
            commandCenter: document.getElementById('command-center'),
            loader: document.getElementById('loader'),
            slides: views.map(id => document.getElementById(id)),
            progressBar: document.getElementById('progress-bar'),
            filterContainer: document.getElementById('filter-container'),
            tabsContainer: document.getElementById('tabs-container'),
            dotsContainer: document.getElementById('nav-dots-container'),
            chartPeriodTitle: document.getElementById('chart-period-title'),
            teamContent: document.getElementById('team-competition-content'),
            leaderboardContent: document.getElementById('leaderboard-content'),
            countdownTimer: document.getElementById('countdown-timer'),
            refreshBtn: document.getElementById('refresh-btn'),
            prevBtn: document.getElementById('prev-slide'),
            nextBtn: document.getElementById('next-slide'),
        };
        
        // --- HELPERS ---
        const getValue = (item, ...keys) => { for (const key of keys) if (item?.[key] != null) return item[key]; return ''; };
        const parseCurrency = (value) => { if (typeof value === 'number') return value; if (typeof value === 'string' && value.trim() !== '') return parseFloat(value.replace(/[^\d.,-]/g, '').replace(/\./g, '').replace(',', '.')) || 0; return 0; };
        const formatCurrency = (value) => value.toLocaleString('en-US', { style: 'currency', currency: 'USD' });
        const getTeamByBroker = (brokerName) => { const shortName = BROKER_MAP[brokerName] || brokerName; for (const team in TEAMS) if (TEAMS[team].includes(shortName)) return team; return 'Sem Time'; };
        const parseDate = (dateStr) => { 
            if (!dateStr || typeof dateStr !== 'string') return null; 
            // Handle YYYY-MM-DD format
            if (dateStr.includes('-')) {
                const parts = dateStr.split('-');
                if (parts.length === 3) return new Date(parts[0], parts[1] - 1, parts[2]);
            }
            // Handle DD/MM/YYYY format
            const parts = dateStr.split('/'); 
            if (parts.length === 3) return new Date(parts[2], parts[1] - 1, parts[0]); 
            return null; 
        };


        // --- DATA PROCESSING ---
        function processData(data, selectedPeriod) {
            const now = new Date(); const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()); const startOfWeek = new Date(today); startOfWeek.setDate(today.getDate() - today.getDay() + (today.getDay() === 0 ? -6 : 1));
            return data.map(item => ({ ...item, parsedDate: parseDate(getValue(item, 'Data')), team: getTeamByBroker(getValue(item, 'Nome')) }))
                .filter(item => {
                    if (!item.parsedDate) return selectedPeriod === 'all'; const itemDate = new Date(item.parsedDate.getFullYear(), item.parsedDate.getMonth(), item.parsedDate.getDate());
                    switch (selectedPeriod) {
                        case 'all': return true; case 'today': return itemDate.getTime() === today.getTime(); case 'this_week': return itemDate >= startOfWeek && itemDate <= today;
                        default: return `${item.parsedDate.getMonth()}_${item.parsedDate.getFullYear()}` === selectedPeriod;
                    }
                });
        }
        function calculateRankings(data) {
            const summary = data.reduce((acc, item) => { 
                const shortName = BROKER_MAP[getValue(item, 'Nome')] || getValue(item, 'Nome'); 
                if (!shortName) return acc; 
                if (!acc[shortName]) acc[shortName] = { brokerName: shortName, team: item.team, totalDeposito: 0, activationCount: 0 }; 
                acc[shortName].totalDeposito += parseCurrency(getValue(item, 'Valor Depósito')); 
                const ativacao = getValue(item, 'Ativação?'); 
                if (ativacao === 'Ativação') acc[shortName].activationCount++; 
                return acc; 
            }, {});
            const allBrokers = Object.values(summary); const valueRanking = [...allBrokers].sort((a, b) => b.totalDeposito - a.totalDeposito); const activationRanking = [...allBrokers].sort((a, b) => b.activationCount - a.activationCount); const maxDeposito = Math.max(...valueRanking.map(b => b.totalDeposito), 1); const maxActivations = Math.max(...activationRanking.map(b => b.activationCount), 1); allBrokers.forEach(broker => { broker.generalScore = ((broker.totalDeposito / maxDeposito) * 0.6) + ((broker.activationCount / maxActivations) * 0.4); }); const generalRanking = allBrokers.sort((a, b) => b.generalScore - a.generalScore);
            return { valueRanking, activationRanking, generalRanking };
        }


        function renderTeamCompetition(data) {
            const kpis = data.reduce((acc, item) => {
                if (!acc[item.team]) acc[item.team] = { totalDeposito: 0, activationCount: 0 };
                acc[item.team].totalDeposito += parseCurrency(getValue(item, 'Valor Depósito'));
                if (getValue(item, 'Ativação?') === 'Ativação') acc[item.team].activationCount++;
                return acc;
            }, {});
            const dg = kpis['DOLLAR GODS'] || { totalDeposito: 0, activationCount: 0 };
            const es = kpis['ELITE SQUAD'] || { totalDeposito: 0, activationCount: 0 };
            const winner = dg.totalDeposito > es.totalDeposito ? 'DOLLAR GODS' : (es.totalDeposito > dg.totalDeposito ? 'ELITE SQUAD' : null);
            
            DOM.teamContent.innerHTML = `
                <div class="fade-in-child transition-all duration-500 ${winner === 'DOLLAR GODS' ? 'winning-team' : ''}" style="animation-delay: 200ms;">
                    <div class="bg-black/20 p-6 rounded-3xl h-full border border-transparent">
                        <h2 class="text-2xl font-bold text-center text-white">DOLLAR GODS</h2>
                        <p class="text-center font-bold mt-1 h-6 ${winner === 'DOLLAR GODS' ? 'text-yellow-400' : ''}">${winner === 'DOLLAR GODS' ? 'LIDERANDO' : ''}</p>
                        <div class="mt-4 text-center space-y-4">
                            <div><p class="text-3xl font-black text-blue-400">${formatCurrency(dg.totalDeposito)}</p><p class="text-gray-400 text-sm">em Depósitos</p></div>
                            <div><p class="text-3xl font-black text-teal-400">${dg.activationCount}</p><p class="text-gray-400 text-sm">Ativações</p></div>
                        </div>
                    </div>
                </div>
                <div class="fade-in-child transition-all duration-500 ${winner === 'ELITE SQUAD' ? 'winning-team' : ''}" style="animation-delay: 300ms;">
                    <div class="bg-black/20 p-6 rounded-3xl h-full border border-transparent">
                        <h2 class="text-2xl font-bold text-center text-white">ELITE SQUAD</h2>
                        <p class="text-center font-bold mt-1 h-6 ${winner === 'ELITE SQUAD' ? 'text-yellow-400' : ''}">${winner === 'ELITE SQUAD' ? 'LIDERANDO' : ''}</p>
                        <div class="mt-4 text-center space-y-4">
                            <div><p class="text-3xl font-black text-blue-400">${formatCurrency(es.totalDeposito)}</p><p class="text-gray-400 text-sm">em Depósitos</p></div>
                            <div><p class="text-3xl font-black text-teal-400">${es.activationCount}</p><p class="text-gray-400 text-sm">Ativações</p></div>
                        </div>
                    </div>
                </div>
            `;
        }


        function renderAnalysisChart(data) {
             const summary = data.reduce((acc, item) => {
                const shortName = BROKER_MAP[getValue(item, 'Nome')] || getValue(item, 'Nome');
                if(!acc[shortName]) acc[shortName] = { brokerName: shortName, totalDeposito: 0, depositoCount: 0 };
                const depositoValor = parseCurrency(getValue(item, 'Valor Depósito'));
                if (depositoValor > 0) { acc[shortName].totalDeposito += depositoValor; acc[shortName].depositoCount++; }
                return acc;
            }, {});
            const chartData = Object.values(summary).sort((a,b) => b.totalDeposito - a.totalDeposito).slice(0, 15);

            const existingChart = Chart.getChart('mainChart');
            if (existingChart) {
                existingChart.destroy();
            }

            Chart.defaults.color = '#9ca3af';
            mainChartInstance = new Chart('mainChart', {
                type: 'bar',
                data: { 
                    labels: chartData.map(d => d.brokerName), 
                    datasets: [
                        { label: 'Valor Total Depositado', data: chartData.map(d => d.totalDeposito), backgroundColor: 'rgba(56, 189, 248, 0.6)', yAxisID: 'y' },
                        { label: 'Quantidade de Depósitos', data: chartData.map(d => d.depositoCount), type: 'line', borderColor: 'rgba(20, 184, 166, 1)', tension: 0.3, yAxisID: 'y1', pointBackgroundColor: '#06b6d4', pointRadius: 4 }
                ]},
                options: { responsive: true, maintainAspectRatio: false,
                    scales: { 
                        y: { type: 'linear', display: true, position: 'left', beginAtZero: true, grid: { color: 'rgba(55, 65, 81, 0.5)' }, ticks: { callback: v => formatCurrency(v) }},
                        y1: { type: 'linear', display: true, position: 'right', beginAtZero: true, grid: { drawOnChartArea: false }, ticks: { stepSize: 1, precision: 0 } }
                    },
                    plugins: { tooltip: { backgroundColor: '#1f2937', callbacks: { label: c => { let l = c.dataset.label || ''; if(l) l += ': '; if(c.dataset.yAxisID === 'y') l += formatCurrency(c.parsed.y); else l += c.parsed.y; return l; }}}}
                }
            });
        }


        function populateFilters(data) {
            const months = new Set();
            data.forEach(item => { const date = parseDate(getValue(item, 'Data')); if (date) { const my = `${date.getMonth()}_${date.getFullYear()}`; const mn = date.toLocaleString('pt-BR', { month: 'long', year: 'numeric' }); months.add(JSON.stringify({ value: my, text: mn.charAt(0).toUpperCase() + mn.slice(1) })); } });
            const sortedMonths = Array.from(months).map(m => JSON.parse(m)).sort((a, b) => { const [am, ay] = a.value.split('_'); const [bm, by] = b.value.split('_'); return (by - ay) || (bm - am); });
            
            DOM.filterContainer.innerHTML = `
                <button class="filter-btn px-3 py-1 rounded-md text-sm font-semibold" data-period="all">Geral</button>
                <button class="filter-btn px-3 py-1 rounded-md text-sm font-semibold" data-period="today">Hoje</button>
                <button class="filter-btn px-3 py-1 rounded-md text-sm font-semibold" data-period="this_week">Esta Semana</button>
                ${sortedMonths.map(m => `<button class="filter-btn px-3 py-1 rounded-md text-sm font-semibold" data-period="${m.value}">${m.text}</button>`).join('')}
            `;
            DOM.tabsContainer.innerHTML = `
                <button data-ranking="value" class="ranking-tab px-4 py-2 text-sm font-semibold rounded-md transition">Depósitos</button>
                <button data-ranking="activation" class="ranking-tab px-4 py-2 text-sm font-semibold rounded-md transition">Ativações</button>
                <button data-ranking="general" class="ranking-tab px-4 py-2 text-sm font-semibold rounded-md transition">Geral</button>
            `;
            DOM.dotsContainer.innerHTML = views.map((_, i) => `<div class="nav-dot" data-index="${i}"></div>`).join('');
        }


        async function fetchDataAndUpdate(isInitial) {
             DOM.countdownTimer.textContent = "Atualizando...";
             try {
                const response = await fetch(urlDoWebhookN8N); if (!response.ok) throw new Error("Network error");
                const result = await response.json(); const fullRawData = (Array.isArray(result) && result[0]?.json) ? result[0].json : result;
                if (!Array.isArray(fullRawData)) throw new Error("Invalid data format");
                rawData = fullRawData.filter(item => { 
                    const date = parseDate(getValue(item, 'Data')); 
                    if (!date) return false; 
                    const year = date.getFullYear(); 
                    const month = date.getMonth(); 
                    return year > 2025 || (year === 2025 && month >= 6); // July 2025 = month 6 (0-indexed)
                });
                
                if (isInitial) {
                    populateFilters(rawData);
                    const julyOption = document.querySelector('[data-period="6_2025"]');
                    currentPeriod = julyOption ? "6_2025" : "all";
                }
                updateActiveFiltersAndTabs();
                const rankings = calculateRankings(processData(rawData, currentPeriod));
                if (Object.keys(previousRankings).length === 0) { updatePreviousRankings(rankings); }
                renderAll();
             } catch(error) { console.error("Fetch failed:", error); DOM.loader.textContent = 'Erro ao carregar dados.'; return; }
             
             if (isInitial) { 
                 DOM.loader.style.display = 'none'; 
                 setupEventListeners(); 
                 showView(0); 
                 startRotation(); 
             }
             
             clearInterval(countdownIntervalId);
             let secondsLeft = DATA_REFRESH_INTERVAL / 1000;
             const updateTimer = () => {
                 secondsLeft--;
                 if(secondsLeft < 0) secondsLeft = 0;
                 const minutes = Math.floor(secondsLeft / 60); const seconds = secondsLeft % 60;
                 DOM.countdownTimer.textContent = `Atualiza em ${minutes}m ${seconds.toString().padStart(2, '0')}s`;
             };
             updateTimer();
             countdownIntervalId = setInterval(updateTimer, 1000);
        }

        initialize();
